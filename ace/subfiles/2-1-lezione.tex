%Lezione 2.1
\documentclass[../ace.tex]{subfiles}

\begin{document}
\section{RISC vs CISC}
\subsection{ISA}
L'ISA (\textit{Instruction set Architecture}) di un processore, non è altro che la lista di istruzioni disponibili
al programmatore, interpretabili dal processore.
Un' istruzione dell'ISA inviata al processore, viene prima trasformata in comandi di microarchitettura
(linguaggio macchina) e poi eseguita dall'hardware.

Un processore viene detto compatibile a livello di ISA con un altro processore, se tutte le sue istruzioni sono interpretabili da quest'ultimo.

La definizione di un ISA è la prima tra le diverse fasi della progettazione della CPU, ed in base a quanti comandi ne fanno parte, il processore si può definire di architettura CISC o RISC.

\subsection{Architettura CISC}
Un'ISA di tipo CISC (\textit{Complex Instruction Set Computer}) è caratterizzata da un vasto numero di istruzioni a disposizione del programmatore, facilitandogli in questo modo la stesura del codice.

Il punto negativo di questa architettura è che la sua realizzazione, essendo ricca di features, risulta poco efficiente e dispendiosa dal punto di vista hardware.
Inoltre le istruzioni utilizzate più di frequente dai programmatori sono un set ridotto (circa il 20\%) di tutte le quelle a disposizione.

\subsection{RISC}
All'esatto opposto ci sono le ISA di tipo RISC (\textit{Reduced Instruction Set Computer}).

Sono ISA che mettono a disposizione un numero ridotto e selezionato di istruzioni, portando il vantaggio di una realizzazione a livello di hardware più semplice e veloce.
Come diretta conseguenza della semplificazione a livello di hardware si hanno tempi di esecuzione più rapidi rispetto alle architetture CISC.

Di contro, essendo il numero di istruzioni a disposizione ridotto, scrivere un programma solitamente risulta più tempo-dispendioso e complesso.

\newpage
\subsection{Confronto fra RISC e CISC}
Altre differenze non ancora discusse su questi due tipi di architettura sono i seguenti:

\begin{table}[h]
    \centering
    \begin{tabu}{|m{.4\textwidth}|m{.4\textwidth}|}
        \rowfont{\centering\bfseries\color{clr-primary}}
        \hline
        RISC & CISC \\
        \hline
        Istruzioni di lunghezza fissa & Istruzioni di lunghezza variabile\\
        \hline
        Decodifica semplice & Decodifica complessa, a più cicli di clock\\
        \hline
        Unità di controllo cablata & Unità di controllo microprogrammata\\
        \hline
        Pochi metodi di indirizzamento & Svariati metodi di indirizzamento\\
        \hline
        Memoria allineata & Memoria non allineata\\
        \hline
        Molti registri di lunghezza fissa ed ortogonali & Pochi registri di varie lunghezze e non ortogonali\\
        \hline
        Processori load/store&\\
        \hline
    \end{tabu}
\end{table}

\subsubsection{Memoria allineata}
In una memoria allineata, i dati vengono disposti ad indirizzi multipli di $n$, portando il vantaggio di avere un rapido accesso alla memoria, dato che gli indirizzi sono semplici da calcolare.

Il difetto, come facilmente intuibile, si verifica nel caso di scrittura di dati di grandezza minore di $n$,

Ovviamente avere una memoria allineata porta con sé lo svantaggio di avere un maggiore consumo di memoria in
caso dovessi salvare dei dati di grandezza minore di $n$.
\\
I registri e la memoria sono collegati, l'approccio RISC cerca di lavorare con la memoria il meno
possibile, attraverso poche modalità di indirizzamento e processori che accedono alla memoria attraverso
due sole istruzioni: load e store.
Per evitare ripetuti accessi alla memoria, i dati vengono salvati temporaneamente in \textbf{registri} interni
al processore. Questi registri possono essere ortogonali (ogni registro può effettuare ogni operazione) nel
caso RISC o non ortogonali (esistono registri specifici per specifiche operazioni) nel caso CISC.

Tempo necessario al processore per eseguire un programma è dato dalla somma
dei clock per instruction di ogni istruzione, moltiplicata al tempo di clock della CPU.
Questo si traduce in:
\[
    T_{\mathit{CPU}} = T_{\mathit{ck}}\sum_i (\mathit{NI}_i \cdot \mathit{CPI}_i)
\]
L'obbiettivo RISC è quello di eseguire la maggior parte delle istruzioni in un solo ciclo di clock,
e rendere l'implementazione più semplice in modo da ridurre la durata del tempo di clock $T_\mathit{CK}$.

\end{document}
