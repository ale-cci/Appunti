%Lezione 2.1
\documentclass[../ace.tex]{subfiles}

\begin{document}
\section{RISC vs CISC}
\subsection{ISA}
L'ISA (\textit{Instruction set Architecture}) di un processore, non è altro che la lista di istruzioni disponibili
al programmatore, interpretabili dal processore.
Un' istruzione dell'ISA inviata al processore, viene prima trasformata in comandi di microarchitettura
(linguaggio macchina) e poi eseguita dall'hardware.

Un processore viene detto compatibile a livello di ISA con un altro processore, se tutte le sue istruzioni sono interpretabili da quest'ultimo.

La definizione di un ISA è la prima tra le diverse fasi della progettazione della CPU, ed in base a quanti comandi ne fanno parte, il processore si può definire di architettura CISC o RISC.

\subsection{Architettura CISC}
Un'ISA di tipo CISC (\textit{Complex Instruction Set Computer}) è caratterizzata da un vasto numero di istruzioni a disposizione del programmatore, facilitandogli in questo modo la stesura del codice.

Il punto negativo di questa architettura è che la sua realizzazione, essendo ricca di features, risulta poco efficiente e dispendiosa dal punto di vista hardware.
Inoltre le istruzioni utilizzate più di frequente dai programmatori sono un set ridotto (circa il 20\%) di tutte le quelle a disposizione.

\subsection{RISC}
All'esatto opposto ci sono le ISA di tipo RISC (\textit{Reduced Instruction Set Computer}).

Sono ISA che mettono a disposizione un numero ridotto e selezionato di istruzioni, portando il vantaggio di una realizzazione a livello di hardware più semplice e veloce.
Come diretta conseguenza della semplificazione a livello di hardware si hanno tempi di esecuzione più rapidi rispetto alle architetture CISC.

Di contro, essendo il numero di istruzioni a disposizione ridotto, scrivere un programma solitamente risulta più tempo-dispendioso e complesso.

\newpage
\subsection{Confronto fra RISC e CISC}
Altre differenze non ancora discusse su questi due tipi di architettura sono i seguenti:

\begin{table}[h]
    \centering
    \begin{tabu}{|m{.4\textwidth}|m{.4\textwidth}|}
        \rowfont{\centering\bfseries\color{clr-primary}}
        \hline
        RISC & CISC \\
        \hline
        Istruzioni di lunghezza fissa & Istruzioni di lunghezza variabile\\
        \hline
        Decodifica semplice & Decodifica complessa, a più cicli di clock\\
        \hline
        Unità di controllo cablata & Unità di controllo microprogrammata\\
        \hline
        Pochi metodi di indirizzamento & Svariati metodi di indirizzamento\\
        \hline
        Memoria allineata & Memoria non allineata\\
        \hline
        Molti registri di lunghezza fissa ed ortogonali & Pochi registri di varie lunghezze e non ortogonali\\
        \hline
        Processori load-store&\\
        \hline
    \end{tabu}
\end{table}

\subsubsection{Memoria allineata}
In una memoria allineata, i dati vengono disposti ad indirizzi multipli di $n$, portando il vantaggio di avere un rapido accesso alla memoria, dato che gli indirizzi sono semplici da calcolare.

Il difetto, come facilmente intuibile, si verifica nel caso di scrittura di dati di grandezza minore di $n$,

\subsubsection{Ortogonalità registri}
Registri e memoria sono collegati.
Un'architettura RISC cerca di ridurre il più possibile gli accessi alla memoria, attraverso un numero ridotto di modalità di indirizzamento
Un'architettura RISC ha poche modalità di indirizzamento e cerca di ridurre il più possibile gli accessi alla memoria. Per questo lavora con processori che comunicano con essa con le due sole operazioni \lstinline{load} e \lstinline{store}.

Per evitare ripetuti accessi, i dati vengono salvati temporaneamente su registri interni al processore stesso. Si definiscono ortogonali (caso RISC) se ogni registro può effettuare ogni operazione o non ortogonali nel caso in cui esistano registri specifici per specifiche operazioni (CISC).

\subsubsection{Istruzioni}
Il tempo impiegato al processore per eseguire un determinato programma è dipendente dal numero di cicli di clock che il processore impiega ad eseguire ogni istruzione. In altre parole, chiamato il tempo di clock $T_\mathit{ck}$ e $\mathit{CPI}_i$ il \textit{clock per instruction} impiegato dall'istruzione $N_i$, il tempo di esecuzione è calcolabile come:
\[
    T_{\mathit{CPU}} = T_{\mathit{ck}}\sum_i (N_i \cdot \mathit{CPI}_i)
\]
Le istruzioni a lunghezza fissa dell'architettura RISC, permettono di essere decodificate in un unico ciclo di clock.
Inoltre, grazie alla logica hardware semplificata, tali architetture permettono di durata del tempo di clock $T_\mathit{ck}$ minore.

Da come si può vedere in formula, entrambe queste caratteristiche portano una riduzione nel tempo di esecuzione complessivo di un programma.

\end{document}
