\documentclass[../ace.tex]{subfiles}

\begin{document}
\section{Microarchitettura CPU}
\subsection{La CPU}
Rete logica combinatoria: rete priva di memoria, che dati ingressi da' delle uscite indipendentemente
dal tempo.
Rete sequenziale: rete che ha memoria, macchina a stati finiti, che dati degli ingressi fornisce
delle uscite dipendenti dallo stato in cui si trova.

Dal punto di vista funzionale possiamo vedere la CPU, come composta da due parti: il data path e
l'unità di controllo.
Il data path di cui componente fondamentale è l'ALU, è una rete logica che si occupa di eseguire le istruzioni, mentre
l'unita di controllo è una macchina a stati finiti che comanda il data path su quali istruzioni eseguire.
\\
Possiamo schematizzare l'unità di controllo come una macchina a stati finiti a tre stati: fetch, decode ed execute.

\subsection{Architettura di riferimento RISC}
Analizziamo adesso un esempio di architettura RISC.

Gli indirizzi di memoria sono riferiti ai byte. Le istruzioni occupano sempre e solo una parola a 32 bit.
Le istruzioni ed i dati si trovano sempre in indirizzi multipli di 4, per questo motivo il program counter
è incrementato di 4 ad ogni istruzione.
Avremo anche 32 registri di uso generale a 32bit. L'insieme dei registri è chiamato register file.

In generale l'esecuzione all'interno di un processore passa attraverso 5 fasi:
una prima fase chiamata Instruction Fetch (IF) dove il processore carica dalla memoria l'istruzione,
successivamente la decodifica nella fase (FT) e la esegue nella fase di execute (EX).
Dopodiché in alcuni casi si ha un accesso alla memoria nella fase di Memory (ME), ed infine
in alcuni casi ho una fase di write-back (WB), dove il risultato delle operazioni è riscritto
nei registri.

Tutte le istruzioni di questa ISA, come già detto hanno una lunghezza fissa di 32bit, ed appartengono a
3 categorie:
\begin{itemize}
    \item Un primo aritmetico logiche,
        Nei primi 6 bit opcode (codice operativo),
        seguiti da 5 che indicano il primo registro sorgente,
        altri 5 bit che indicano il secondo registro,
        5 che indicano il registro destinazione
        ed i rimanenti 11 fanno riferimento all'operazione specifica dell'ALU (somma, sottrazione, ...).
        \begin{lstlisting}
    add  r4,r2,r5
    \end{lstlisting}

    \item Un secondo formato utilizzato per accesso alla memoria e salti condizionati.
        I primi 6 bit di codice operativo,
        a seguire altri 5 ad indicare il primo registro
        ed altri 5 ad indicare il secondo registro (come nel primo caso)
        16 che indicano un offset o un dato.

        \begin{lstlisting}
    je  r2,r3,0045h
        \end{lstlisting}
    \item Un terzo ed ultimo caso utilizzato per i salti incondizionati.
        I primi 6 bit indicano sempre l'opcode ed i rimanenti indicano l'indirizzo di termine del
        salto.

        \begin{lstlisting}
    jmp 0045h
        \end{lstlisting}
\end{itemize}
In questa prima architettura assumiamo che non ci sia lo stack (zona di memoria organizzata a pila LIFO),
accessibile attraverso istruzioni apposite come \lstinline{push} e \lstinline{pop}.

Oltre a salto condizionato ed incondizionato esiste un terzo tipo di salto: la chiamata a funzione.
È un tipo di salto incondizionato particolare, dato che quando eseguito è necessario salvare il valore
del program counter per poter proseguire l'esecuzione una volta terminata la funzione.

Siccome non abbiamo uno stack, il program counter è salvato nell'indirizzo $R_{31}$
%27: ragionamento di funzionamento dell'ALU

Per selezionare le operazioni da far eseguire all'ALU è specificato un ingresso chiamato opalu, dove vengono
specificate le operazioni. Oltre all'uscita dell'operazione vengono tornati dei valori aggiuntivi come
il flag di zero (messo ad uno quando il risultato dell'ALU è zero), ed il flag di segno (messo ad 1 quando il
risultato è negativo).

\subsubsection{Load e Store}
%35
Load e store permettono rispettivamente lettura e scrittura in memoria.
Entrambe prendono in ingresso un registro base, uno destinazione ed un offset. Per accedere al dato l'offset viene sommato
al registro base ottenendo un nuovo indirizzo, il cui contenuto è salvato nel registro destinazione.
I dati vengono direttamente presi dal bus attraverso buffer 3-state, lettura e scrittura possono essere disabilitate con i segnali
$Mr$ (\textit{Memory Read}) e $Mw$ (\textit{Memory Write}),

\subsubsection{Register File}
Componente che ha come ingressi 5 bit che identificano il primo registro, 5bit per il secondo registro,
5bit per il registro destinazione, ed i rimanenti 32 per il dato in ingresso.
Le due porte in uscita riportano i dati letti rispettivamente dal registro sorgente 1 e 2.
%49

\subsection{CPU monociclo}
% TODO: aggiungere disegno CPU monociclo
In una CPU monociclo, tutte le istruzioni impiegano un solo ciclo di clock. È una struttura molto semplice, ma potenzialmente anche molto
lenta, dato che il tempo di esecuzione di ogni istruzione deve essere pari al tempo di esecuzione dell'istruzione più lenta.

Prendendo come esempio l'istruzione \lstinline{st R6,R1, 20},
\begin{itemize}
    \item in fase di fetch: recupero istruzione dalla memoria.
    \item fase di decode
    \item fase di execute: salva dato in memoria.
\end{itemize}

\def\tmono{T_\text{mono}}
\def\tmulti{T_\text{multi}}

Dato che in un unico ciclo di clock devo eseguire sia fetch che store, devo necessariamente avere due memorie separate.
È inevitabile l'uso di un'architettura di Harvard (pagina \pageref{sec:architettura_harvard}).
Oltre alla doppia memoria portata dall'architettura è necessario duplicare altre risorse, come ad esempio l'ALU, richiesta
per incrementare sia valore del program counter che per calcolare l'indirizzo di destinazione del dato.

Tra le varie operazioni richieste dall'ISA, il tempo di esecuzione maggiore è dovuto sicuramente alla \lstinline{load} (vedi
tabella \ref{tab:tempi_esecuzione_monociclo}),
che oltre alle fasi di fetch e decode richiede: calcoli dall'ALU, writeback ed accesso alla memoria.
Chiamato il suo tempo di esecuzione $\tmono$ ed $N$ il numero di istruzioni, il tempo di esecuzione del programma è $\tmono \cdot N$.

\begin{table}[t]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
    & Fetch  & Decode & ALU & Memory & Writeback & Totale \\
    \hline
        Aritm.   & 30 & 5 &  12 &        &         5 &      52\\
        Load     & 30 & 5 &  12 &     30 &         5 &      82\\
        Store    & 30 & 5 &  12 &     30 &           &      77\\
        jmp cond.& 30 & 5 &  12 &        &           &      47\\
        jmp      & 30 & 5 &     &        &           &      35\\
        jal/call & 30 & 5 &     &        &         5 &      40\\
        \hline
    \end{tabular}
    \caption{Esempio tempi di esecuzione in architettura monociclo}
    \label{tab:tempi_esecuzione_monociclo}
\end{table}

% Lezione 2.6
\subsection{CPU multiciclo}
Suddivide ogni stadio di esecuzione dell'istruzione in un ciclo di clock.
Il ragionamento alla base di questa architettura è che molte istruzioni hanno un tempo di istruzione notevolmente inferiore ad altre.
In altre parole, chiamata $\sum\tmulti$ il tempo di esecuzione di una singola istruzione il numero di istruzioni per cui
$\sum\tmulti > \tmono$ sarà inferiore al numero di istruzioni per cui $\sum\tmulti < \tmono$.
Ne consegue che l'architettura multiciclo è in media più veloce dell'architettura monociclo.

Inoltre non è più necessario duplicare componenti come ALU e memoria, dato che l'accesso ai dati e incremento PC/calcolo registri è
eseguito in due cicli di clock differenti.

% TODO: aggiungere schema generale architettura multiciclo (slide 60)
\begin{itemize}
    \item Fetch:
        Viene letto in memoria ll contenuto del program counter, e nello stesso ciclo attraverso l'alu aggiorno il program counter e lo
        salvo in pc.
    \item Decode:
        Analogamente alla precedente, il codice operativo di PC entra in IR, e viene decodificato.
        Leggo il contenuto dei registri R1 ed R2.
        Utilizzo l'alu per calcolare a prescindere il valore del registro di destinazione (destinazione del salto condizionato
        viene calcolata prima di verificare le condizioni)
    \item Operaaione Aritmetia:
        Eseguo l'istruzione utilizzando i dati calcolati nelle fasi precedenti.
    \item Load e Store:
        Sempre attraverso buffer 3-state salvano o leggono dati dalla memoria all'indirizzo destinazione calcolato nelle fasi
        precedenti.
    \item Writeback:
        In caso di operazione aritmetica prendo il valore in uscita dell'ALU e lo riporto nel register file nella porta dati.
        In caso di load, il valore di uscita della memoria viene riportato nella porta dati del register file.
        In caso di JAL PC1 (valore precedente di PC) entra nel register file.
\end{itemize}
Interfacce con l'esterno: bus di dati attraverso buffer 3-state, in uscita al bus degli indirizzi arriva o alu-out o pc.

\subsubsection{Segnali di controllo architettura multiciclo}

\end{document}
