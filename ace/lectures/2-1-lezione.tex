%Lezione 2.1
\documentclass[../ace.tex]{subfiles}

\begin{document}
\section{RISC vs CISC}
\subsection{ISA}
L'ISA (\textit{Instruction set Architecture}) di un processore, non è altro che la lista di istruzioni disponibili
al programmatore, interpretabili dal processore.
Un' istruzione dell'ISA inviata al processore, viene prima trasformata in comandi di microarchitettura
(linguaggio macchina) e poi eseguita dall'hardware.
Un processore viene detto compatibile a livello di ISA con un altro processore, se tutte le istruzioni di
quest'ultimo sono interpretabili dal processore.

La definizione di un ISA è la prima tra le diverse fasi della progettazione della CPU, ed in base
a quanto verbosa (quanti comandi ne fanno parte), il processore si può definire di architettura CISC o RISC.

\subsection{CISC}
Un' ISA di tipo CISC (\textit{Complex Instruction Set Computer}) facilita il compito del, fornendo a disposizione
un vasto numero di istruzioni. Di contro ha che la sua realizzazione in hardware spesso risulta non
efficiente.
Inoltre le istruzioni utilizzate più di frequente dai programmatori sono approssimativamente il 20\% di quelle
disponibili.

\subsection{RISC}
All'esatto opposto ci sono le ISA di tipo RISC (\textit{Reduced Instruction Set Computer}).
È un ISA semplice più vicina all'hardware, hanno un'implementazione più veloce e più semplice.
Fornisce un set di istruzioni ristretto ma efficiente.
Di contro, essendo il numero di istruzioni a disposizione ridotto, scrivere un programma solitamente risulta
più complesso e si impiega più tempo.
% 20:19
\subsection{Confronto fra RISC e CISC}
Altre differenze tra i due tipi di architettura, non ancora riportate, ma da tener presente sono:

\vspace{10pt}
\noindent\begin{minipage}{.48\textwidth}
    \begin{tcolorbox}[title={\centering RISC}]
        \begin{itemize}[leftmargin=*]
            \item Istruzioni di lunghezza fissa
            \item Decodifica più semplice
            \item Unità di controllo cablata
            \item pochi metodi di indirizzamento
            \item memoria allineata
            \item molti registri di lunghezza fissa ed ortogonali
            \item processori load/store
        \end{itemize}
    \end{tcolorbox}
\end{minipage}
\begin{minipage}{.51\textwidth}
    \begin{tcolorbox}[title={\centering CISC}]
        \begin{itemize}[leftmargin=*]
            \item Codice operativo e istruzioni di lunghezza variabile
            \item Decodifica complessa, a più cicli di clock
            \item Unità di controllo microprogrammata
            \item Molta flessibilità nei metodi di indirizzamento
            \item memoria non allineata
            \item pochi registri di varie lunghezze e non ortogonali
        \end{itemize}
    \end{tcolorbox}
\end{minipage}
\vspace{10pt}

% --HERE
Memoria Allineata: Accesso più veloce ai ai dati, non efficiente per 'storing' dei dati.
\\
Per cercare di accedere il meno possibile alla memoria vengono utilizzati \textbf{Registri}.
L'architettura RISC utilizza molti registri oriogonali (ogni registro può effettuare ogni operazione),
mentre CISC utilizza meno registri non ortogonali, ovvero esistono registri specifici per specifiche operazioni.
\section{Lezione 3}
CPU: Unità di controllo a stati finiti (fetch, decode, execute)

PC: Program Counter

MR: Memory register

DR: Data register

La memoria si interfaccia con:
\begin{itemize}
    \item Bus di indirizzi (solo in input)
    \item Bus di dati, \\utilizzato sia per leggere che per scrivere i dati sulla memoria
\end{itemize}

Con $R_{2..n}$ vengono indicati i vari registri

Register File: (slide 43)

\subsection{CPU Monociclo}
\textbf{Modello Harvard}: Due memorie separate.% Aggiungere descrizione

Richiede due memorie separate, siccome accede due volte alla memoria nello stesso ciclo di clock.

\begin{enumerate}
    \item fetch: accede alla memoria per leggere istruzioni della CPU
    \item decode
    \item execute
    \item memoria
\end{enumerate}

Writeback (WB): Il contenuto letto dalla memoria viene scritto su un registro.

Siccome tutte le operazioni vengono eseguite in un unico ciclo di clock, il tempo impiegato da ciascuna istruzione diventa uguale al tempo impiegato dalla 'funzione' più lenta: $T_{mono} = 83 ns$.
\\
Il tempo di esecuzione del programma diventa $N \cdot 83ns$

\end{document}
