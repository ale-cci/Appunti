\documentclass[../ace.tex]{subfiles}

\begin{document}
\section{Lezione 2}
ISA: Instruction Set Architecture, lista id istruzioni disponibili al programmatore utilizzate dal processore

CISC: Complex Instruction Set Computer
\\
Facilita la programmazione, fornendo al programmatore un vasto numero di istruzioni possibili\\
, aumentando però la complessitá a livello di microcodice.


RISC: Reduced Set Computer, Ha un ISA più vicina all Hardwere, e piu lontana dal programmantore.
\\
Ha un set efficente e limitato di istruzioni, basato sul fatto che solo un ridotto numero di istruzioni è utilizzato.
\\
\textit{Confronto 'RISC' e 'CISC' a lezione 3.1 in 20:19}

Memoria Allineata: Accesso più veloce ai ai dati, non efficiente per 'storing' dei dati.
\\
Per cercare di accedere il meno possibile alla memoria vengono utilizzati \textbf{Registri}.
L'architettura RISC utilizza molti registri oriogonali (ogni registro può effettuare ogni operazione),
mentre CISC utilizza meno registri non ortogonali, ovvero esistono registri specifici per specifiche operazioni.
\section{Lezione 3}
CPU: Unità di controllo a stati finiti (fetch, decode, execute)

PC: Program Counter

MR: Memory register

DR: Data register

La memoria si interfaccia con:
\begin{itemize}
    \item Bus di indirizzi (solo in input)
    \item Bus di dati, \\utilizzato sia per leggere che per scrivere i dati sulla memoria
\end{itemize}

Con $R_{2..n}$ vengono indicati i vari registri

Register File: (slide 43)

\subsection{CPU Monociclo}
\textbf{Modello Harvard}: Due memorie separate.% Aggiungere descrizione

Richiede due memorie separate, siccome accede due volte alla memoria nello stesso ciclo di clock.

\begin{enumerate}
    \item fetch: accede alla memoria per leggere istruzioni della CPU
    \item decode
    \item execute
    \item memoria
\end{enumerate}

Writeback (WB): Il contenuto letto dalla memoria viene scritto su un registro.

Siccome tutte le operazioni vengono eseguite in un unico ciclo di clock, il tempo impiegato da ciascuna istruzione diventa uguale al tempo impiegato dalla 'funzione' più lenta: $T_{mono} = 83 ns$.
\\
Il tempo di esecuzione del programma diventa $N \cdot 83ns$

\end{document}
