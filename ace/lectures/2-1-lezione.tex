%Lezione 2.1
\documentclass[../ace.tex]{subfiles}

\begin{document}
\section{RISC vs CISC}
\subsection{ISA}
L'ISA (\textit{Instruction set Architecture}) di un processore, non è altro che la lista di istruzioni disponibili
al programmatore, interpretabili dal processore.
Un' istruzione dell'ISA inviata al processore, viene prima trasformata in comandi di microarchitettura
(linguaggio macchina) e poi eseguita dall'hardware.
Un processore viene detto compatibile a livello di ISA con un altro processore, se tutte le istruzioni di
quest'ultimo sono interpretabili dal processore.

La definizione di un ISA è la prima tra le diverse fasi della progettazione della CPU, ed in base
a quanto verbosa (quanti comandi ne fanno parte), il processore si può definire di architettura CISC o RISC.

\subsection{CISC}
Un' ISA di tipo CISC (\textit{Complex Instruction Set Computer}) facilita il compito del, fornendo a disposizione
un vasto numero di istruzioni. Di contro ha che la sua realizzazione in hardware spesso risulta non
efficiente.
Inoltre le istruzioni utilizzate più di frequente dai programmatori sono approssimativamente il 20\% di quelle
disponibili.

\subsection{RISC}
All'esatto opposto ci sono le ISA di tipo RISC (\textit{Reduced Instruction Set Computer}).
È un ISA semplice più vicina all'hardware, hanno un'implementazione più veloce e più semplice.
Fornisce un set di istruzioni ristretto ma efficiente.
Di contro, essendo il numero di istruzioni a disposizione ridotto, scrivere un programma solitamente risulta
più complesso e si impiega più tempo.
% 20:19
\subsection{Confronto fra RISC e CISC}
Altre differenze tra i due tipi di architettura, non ancora riportate, ma da tener presente sono:

\vspace{10pt}
\noindent\begin{minipage}{.48\textwidth}
    \begin{tcolorbox}[title={\centering RISC}]
        \begin{itemize}[leftmargin=*]
            \item Istruzioni di lunghezza fissa
            \item Decodifica più semplice
            \item Unità di controllo cablata
            \item pochi metodi di indirizzamento
            \item memoria allineata
            \item molti registri di lunghezza fissa ed ortogonali
            \item processori load/store
        \end{itemize}
    \end{tcolorbox}
\end{minipage}
\begin{minipage}{.51\textwidth}
    \begin{tcolorbox}[title={\centering CISC}]
        \begin{itemize}[leftmargin=*]
            \item Codice operativo e istruzioni di lunghezza variabile
            \item Decodifica complessa, a più cicli di clock
            \item Unità di controllo microprogrammata
            \item Molta flessibilità nei metodi di indirizzamento
            \item memoria non allineata
            \item pochi registri di varie lunghezze e non ortogonali
        \end{itemize}
    \end{tcolorbox}
\end{minipage}
\vspace{10pt}

% --HERE
In una memoria allineata, i dati vengono disposti ad indirizzi multipli di $n$.
Il vantaggio ovvio che si ha utilizzando questa struttura è un rapido accesso alla memoria.
Ovviamente avere una memoria allineata porta con sé lo svantaggio di avere un maggiore consumo di memoria in
caso dovessi salvare dei dati di grandezza minore di $n$.
\\
I registri e la memoria sono collegati, l'approccio RISC cerca di lavorare con la memoria il meno
possibile, attraverso poche modalità di indirizzamento e processori che accedono alla memoria attraverso
due sole istruzioni: load e store.
Per evitare ripetuti accessi alla memoria, i dati vengono salvati temporaneamente in \textbf{registri} interni
al processore. Questi registri possono essere ortogonali (ogni registro può effettuare ogni operazione) nel
caso RISC o non ortogonali (esistono registri specifici per specifiche operazioni) nel caso CISC.

Tempo necessario al processore per eseguire un programma è dato dalla somma
dei clock per instruction di ogni istruzione, moltiplicata al tempo di clock della CPU.
Questo si traduce in:
\[
    T_{\mathit{CPU}} = T_{\mathit{ck}}\sum_i (\mathit{NI}_i \cdot \mathit{CPI}_i)
\]
L'obbiettivo RISC è quello di eseguire la maggior parte delle istruzioni in un solo ciclo di clock,
e rendere l'implementazione più semplice in modo da ridurre la durata del tempo di clock $T_\mathit{CK}$.

\end{document}
