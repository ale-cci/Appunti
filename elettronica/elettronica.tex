\documentclass{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage[makeroom]{cancel}
\usepackage[usestackEOL]{stackengine}
\usepackage{mathtools}
\usepackage[oldvoltagedirection]{circuitikz}
\usepackage{multicol}
\usepackage{tikz}
\usepackage{pgfplots}

\graphicspath{{../}}
\ctikzset{bipoles/length=1.2cm}
\pgfplotsset{compat=1.16}

\begin{document}

% \include{parte_a}
% \include{quaderno}

%\include{appunti_diodo}
\include{appunti_21-05-19}
\include{appunti_22-05-19}
\include{appunti_23-05-19}

% Appunti Tue 28 May 2019 02:50:49 PM CEST
\section{Integrazione di un segnale}


\begin{figure}[H]
    \centering
    \begin{circuitikz}
        \draw (0, 0)
        node[above]{$V_i$}
        to[R, *-*, l=$R$, i=$I_R$] ++(2, 0)
        coordinate(ing1)
        -- ++(0, 1)
        to[C, l=$C$, i=$I_C$] ++(2.5, 0)
        coordinate(tip);
        \draw (ing1) node[op amp, anchor=-](am){};
        \draw(am.+) -- +(0, -1) node[eground]{};
        \draw(am.out) to[short, -*] ++(2, 0)
        node[right] {$V_u$};
        \draw(tip) -- (tip |- am.out);
        \draw(am.-) to[open, v>=$V_{id}$] (am.+);
    \end{circuitikz}
    \caption{Circuito integratore invertente}
\end{figure}
In \underline{AG}:

\[ V_{Id} = 0 \rightarrow V^- = V^+ = 0 \]
\[
    \begin{rcases}
        I_R = \frac{V_i - V^- }{R}\\
        I_C = C\frac{d(V^- - V_u}{dt}\\
        -I_r = \cancel{I^-} + I_c
    \end{rcases}\Rightarrow
    \frac{V_i}{R} = -C \frac{dV_u}{dt}
    \Rightarrow \frac{dV_u}{dt} = -\frac{V_i}{RC} \rightarrow \int_0^t \frac{dV_u}{dt} dt = \int_0^t -\frac{Vi(t)}{RC} dt
\]
\[ V_u(t) - V_u(0) = -\frac{1}{RC}\int_0^t V_i(t)dt \]

\begin{center}
    \framebox{$ V_u (t) = V_u(0) - \frac{1}{RC}\int_0^t V_i(t) dt $}
\end{center}

Tutto questo vale finche la tensione di uscita rimane compresa fra $\pm V_M$

A Differenza del derivatore, questo circuito ha memoria

\subsection{}

\begin{figure}[H]
    \centering
    \begin{circuitikz}
        \draw (0, 0)
        node[above]{$V_i$}
        to[R, *-*, l=$R_1$, i=$I_R$] ++(2, 0)
        coordinate(ing1)
        -- ++(0, 1)
        to[R, l=$R_2$, i=$I_R$] ++(2.5, 0)
        coordinate(tip);
        \draw (ing1) node[op amp, anchor=-](am){};
        \draw(am.+) -- +(0, -1) node[]{$V_i$};
        \draw(am.out) to[short, -*] ++(2, 0)
        node[right] {$V_u$};
        \draw(tip) -- (tip |- am.out);
        \draw(am.-) to[open, v>=$V_{id}$] (am.+);
    \end{circuitikz}
    \caption{Circuito integratore invertente}
\end{figure}

\underline{AG}
\[
    \begin{rcases}
        V^- = V_i \\
        I_1 = \frac{0-V^-}{R_1}\\
        I_2 = \frac{V^- - V_u}{R_1}\\
        I_2 = \cancel{I^-} + I_c\\
    \end{rcases}
    \frac{V_i}{R_1} = \frac{V_i - V_u}{R_2}
\]
\[
    -V_i \left(\frac{1}{R_1} + \frac{1}{R_2} \right) = - \frac{V_u}{R_2}
\]
\[ V_u = \left( \frac{1}{R_1} - \frac{1}{R_2} \right) R_2 V_i \]
\[ V_u = \left( 1 + \frac{R_2}{R_1} \right) V_i \xrightarrow{R_2 \to 0} V_u = V_i  \]


\begin{minipage}{0.45\textwidth}
    \begin{circuitikz}
        \draw (0, 0) node[eground]{} to[R, l=$R_1$] (0, 2) to[R, -*, l=$R_L$] (0, 4) node[right]{$V_{DD}$};
        \draw(0, 2) node[anchor=east]{$V_u$}-- (2, 2) to[R, l=$R_L$] (2, 0) node[eground]{};
    \end{circuitikz}
\end{minipage}
\begin{minipage}{0.5\textwidth}
    \begin{circuitikz}
        \draw (0, 0) node[eground](G){} to[R, l=$R_1$] (0, 2) to[R, -*, l=$R_L$] (0, 4) node[right]{$V_{DD}$};
        \draw(0, 2) node[anchor=east]{$V_u$} -- (1, 2) node[op amp, anchor=+](amp){} ;
        \draw (amp.out) to[R, l=$R_L$] (amp.out |- G) node[eground]{};
        \draw (amp.-) -- ++(0, 1) coordinate(angl)-- (angl-|amp.out) -- (amp.out);
    \end{circuitikz}
\end{minipage}

Da Partitore di tensione:
\[ V_u = \frac{R_1}{R_1 R_2} V_{DD}  = \frac{1}{1+\frac{R_2}{R_1}} V_{DD}\]

\[ V_u = \frac{1}{1 + \frac{R_2}{R_1 \parallel R_L}} V_{DD}  \qquad R_1 \parallel R_L < R_1\]


\subsection{Circuito con piu ingressi}


\begin{figure}[H]
    \centering
    \begin{circuitikz}
        \draw (-1, 0)
        node[above]{$V_i$}
        to[R, *-*, l=$R_1$, i=$I_R$] (2, 0)
        coordinate(ing1)
        -- ++(0, 1)
        to[R, l=$R$, i=$I_R$] ++(2.5, 0)
        coordinate(tip);
        \draw (-1, -1) node[above]{$V_2$} to[R, l=$R_2$, *-] (1.5, -1) -- (1.5, 0);
        \draw (ing1) node[op amp, anchor=-](am){};
        \draw(am.+) -- +(0, -1) node[eground]{};
        \draw(am.out) to[short, -*] ++(2, 0)
        node[right] {$V_u$};
        \draw(tip) -- (tip |- am.out);
    \end{circuitikz}
    \caption{Circuito sommatore analogico}
\end{figure}

\underline{AG}
\[ V_id = 0 \rightarrow V^- = V^+ = 0\]
Applicando Kirkoff

\[ \begin{rcases}
        I_1 + I_2 = I^- + I_R\\
        I_1 = \frac{V_1 - \cancel{V^-}}{R_1} \\
        I_2 = \frac{V_2 - \cancel{V^-}}{R_2} \\
        I_R = \frac{V^- - V_u}{R} = -\frac{V_u}{R}\\
    \end{rcases}
    \frac{V_1}{R_1} + \frac{V_2}{R_2} = -\frac{V_u}{R} \rightarrow V_u = -R\left( \frac{V_1}{R_1} + \frac{V_2}{R_2}\right)  \xrightarrow{R_1 = R_2 = R^*} V_u = -\frac{R}{R^*}(V_1 + V_2)
\]

Questo circuito permette di calcolare direttamente in maniera analogica una combinazione lineare di ingressi

Provando a progettare un sommatore di tipo digitale:

(X: Grafico con sommatoria)

\textbf{ADC}: Analog Digital converter

\textbf{DAC}: Digital Analog Converter

Blocco Sommatore: Es $3+6$

\begin{tabular}{c c c c c}
    1 & 1 & \\
    0 & 0 & 1 & 1 & + \\
    0 & 1 & 1 & 0 & = \\
    \hline
    1 & 0 & 0 & 1
\end{tabular}

(X: Grafico sommatore a propagazione di riporto)
(RCA: Ripple Carry Adder)

Dal circuito possiamo distinguere un HA (Half Adder) e 3 FA (Full Adder)

In questo caso aggiungere bit vuol dire aggiungere ritardo, siccome \'e tutto in cascata. Nel caso analogico \'e tutto in parallelo. Qundi aggiungere altri bit non comporta ritardo

\begin{tabular}{c c|c c}
    a & b & $c_H$ & $S_H$\\
    \hline
    0 & 0 & 0 & 1 \\
    0 & 1 & 0 & 1 \\
    1 & 0 & 0 & 1 \\
    1 & 1 & 1 & 0
\end{tabular}

% \begin{circuitikz}
%     \draw (0, 0) node[left](zero){$a$} to[short, *-]  (2, 0) node[and port, anchor=in 1](ch){}
%     \node at (1.5, |- ch.in 2)[jump crossing](X);
%     \draw (0, -2) node[left]{$b$} to[short, *-] (1, -2) -- (1, |- X.west) -- (X.west);
%     \draw (X.east) -- (ch.in 2);
%     \draw (X.north |- zero) -- (X.north);
%     \draw (X.south) -- (X.south |- ,-2) ;
% \end{circuitikz}

$1^a$ mappa k
\begin{center}
    \begin{tabular}{c|c c c c}
    & 00 & 01 & 11 & 10\\
    \hline
        0 & 0 & 0 & 1 & 0\\
        1 & 0 & 1 & 1 & 1\\
    \end{tabular}
\end{center}
\[ C_{out} = ab + C_{in} (a+b) = \]

ricordando che $a + b = ab + \bar{a}b + a\bar{b}$ (Dalla tabella dell'or)
\[ ab \cancel{(a + C_{in})} + C_{in}(a\bar{b} + \bar{a}b) = C_H ++ C_{in} \cdot S_H \]

$2^a$ mappa k
\begin{center}
    \begin{tabular}{c|c c c c}
    & 00 & 01 & 11 & 10\\
    \hline
        0 & 0 & 1 & 0 & 1\\
        1 & 1 & 0 & 1 & 0\\
    \end{tabular}
\end{center}
\[ S = \bar{C_{in}} \bar{a} b + \bar{C_{in}} a \bar{b} + C_{in} \bar{a}\bar{b} + C_{in} ab \]
\[ S = \bar{C_{in}}( a\bar{b} + \bar{a}b) + C_{in}(ab + \bar{a}\bar{b}) = \bar{C_{in}} S_H + C_{in} \bar{S_H} = C_{in} \oplus S_H\]

La porta analogica \'e piu veloce e meno ingombrante di quella digitale, ma non \'e immune al disturbo


% Appunti Wed 29 May 2019 03:40:33 PM CEST

\section{Circuito Sottrattore}
\begin{circuitikz}
    \draw (0, 0) node[left]{$V_i$} to[R, o-] (2, 0)
    node[op amp, anchor=-](amp){};
    \draw (amp.+) to[R] ++(0, -2) node[eground]{};
    \draw (amp.-) -- ++(0, 1) coordinate(ang)
    (ang) to[R]  (amp.out |- ang) -- (amp.out) to[short, -o] ++(1, 0) node[right]{$V_u$};
    \draw (0, |- amp.+) node[left]{$V_2$} to[R, o-] (amp.+);
\end{circuitikz}
\underline{AG}

\[
    \begin{rcases}
        V_{id} = 0 \rightarrow V^+ = V^-\\
        \begin{rcases}
            I_1 = I_2 + \cancel{I^+} \\
            I_1 = \frac{V_2 - V^+}{R} \\
            I_2 = \frac{V^+}{R}
        \end{rcases}
        \rightarrow \frac{V_2 + V^+}{\cancel{R}} = \frac{V^+}{\cancel{R}} \rightarrow V_2 = 2V^+ \rightarrow V^+ = \frac{V_2}{2}
    \end{rcases} \rightarrow
    \begin{rcases}
        V^- = \frac{V_2}{2}\\
        I_3 = I_4 + \cancel{I^-}\\
        I_3 = \frac{V_1 - V^-}{R}\\
        I_4 = \frac{V^- - V_u}{R}
    \end{rcases}
    \frac{V_1 - \frac{V_2}{2}}{\cancel{R}} = \frac{\frac{V_2}{2} - V_u}{\cancel{R}}
\]

\begin{center}
    \framebox{$V_u = V_2 - V_1$}
\end{center}


\section{Amplificatore logaritmico}
\begin{circuitikz}
    \draw (0, 0) node[left]{$V_i$} to[R, o-] (2, 0)
    node[op amp, anchor=-](amp){};
    \draw (amp.+) -- ++(0, -1) node[eground]{};
    \draw (amp.-) -- ++(0, 1) coordinate(ang)
    (ang) to[diode]  (amp.out |- ang) -- (amp.out) to[short, -o] ++(1, 0) node[right]{$V_u$};
\end{circuitikz}
\underline{AG}
\[
    \begin{rcases}
        V_{id} = 0 \rightarrow V^+ = V^- = 0\\
        I_R = I_D + \cancel{I^-}\\
        I_R = \frac{V_i - V^-}{R}
        I_D = IS \left(e^{\frac{(V^- - V_u)}{V_T}} - 1\right)
    \end{rcases}\rightarrow
    \frac{V_i}{RI_s} = \left(e^{\frac{(V^- - V_u)}{V_T}} - 1\right) \rightarrow e^{\frac{(V^- - V_u)}{V_T}} = \frac{V_i}{RI_S} + 1
    \xrightarrow{\ln} \ln\left(e^{-\frac{V_u}{V_T}}\right) = \ln\left( \frac{V_i}{RI_S} + 1\right)
\]
\[ V_u = -V_T \ln\left( \frac{V_i}{RI_S -1} \right) \]
(Grafico: Amplificatore logaritmico)

\section{Amplificatore esponenziale/Antilogaritmico}
\underline{AG}
\[
    \begin{rcases}
        V_{id} = 0 \rightarrow V^+ = V^- = 0\\
        I_D = I_R + \cancel{I^-}\\
        I_D = I_S \left(e^{\frac{V_i - V^-}{V_T}} -1 \right)\\
        I_R = \frac{V^- - V_u}{R}
    \end{rcases} \rightarrow
    I_S \left(e^{\frac{V_i}{V_T}}-1\right) = -\frac{V_u}{R} = -RI_S \left( e^{\frac{V_i}{V_t} -1}\right)
\]

Amplificatore antilogaritmico

Ricordando che
\[ \ln (A+B) = \ln(A) \cdot \ln(B) \]

(X: Circuito Sommatore)

Non \'e un caso che il ramoin retroazione sia sul morsetto negativo:

\begin{minipage}{0.45\textwidth}
    \begin{tikzpicture}
        \begin{axis}[axis lines=middle, ymax=3, ymin=-3, yticklabels=\empty, xticklabels=\empty, xlabel=$V_i$, ylabel=$V_u$]
            \addplot[color=red, domain=-4:-1]{2};
            \addplot[color=red, domain=1:4]{-2};
            \addplot+[mark=none, color=red] coordinates{(-1, 2) (1, -2)};
        \end{axis}
    \end{tikzpicture}
\end{minipage}
\begin{minipage}{0.5\textwidth}
    \begin{tikzpicture}
        \begin{axis}[axis lines=middle, ymax=3, ymin=-3, yticklabels=\empty, xticklabels=\empty, xlabel=$V_i$, ylabel=$V_u$]
            \addplot[color=red, domain=-1:4]{2};
            \addplot[color=red, domain=-4:1]{-2};
            \addplot+[mark=none, color=red] coordinates{(-1, 2) (1, -2)};
        \end{axis}
    \end{tikzpicture}
\end{minipage}

\underline{AG}
\[
    \begin{rcases}
        V_{id} = 0 \rightarrow V^+ = V^- = 0 \\
        I_1 = I_2 + \cancel{I^+}\\
    \end{rcases} \frac{V_i}{R_1} = -\frac{V_u}{R_2} \rightarrow V_u = -\frac{R_2}{R_1}V_i \qquad \text{Per} -V_M < V_u < V_M
\]

\underline{SAT +}

\[
    \begin{rcases}
        \begin{rcases}
            V_{id} > 0, \quad V_u = +V_M\\
            V_{id} = V^+ - V^-
        \end{rcases} \rightarrow
        V^+ > 0\\
        \frac{V_i - V^+ }{R_1} = \frac{V^+ - V_u}{R_2}
    \end{rcases}
    \frac{V_i - V^+}{R_1} = \frac{V^+ - V_M}{R_2}
\]
\[ V^+ \left( \frac{1}{R_2} + \frac{1}{R_1} \right) = \frac{V_i}{R_1} + \frac{V_M}{R_2} \]
\[V^+ \left(\frac{R_1 + R_2}{\cancel{R_1 R_2}}\right) = \frac{V_iR_2 + V_M R_1}{\cancel{R_1 R_2}} \]
\[ V^+ = \frac{R_2V_i + R_1 V_M}{\cancel{R_1 + R_2}} > 0\]
\[ \cancel{R_2} V_i > -\frac{R_1 V_M}{R_2} \]

\underline{SAT -}
\[
    \begin{rcases}
        V_{id} < 0 \rightarrow V^+ - V^- < 0 \rightarrow V^+ < 0\\
        V_u = -V_M
    \end{rcases} \ldots \rightarrow V^+ = \frac{R_2V_i - R_1V_M}{\cancel{R_1 + R_2}} < 0 \Rightarrow \cancel{R_2} V_i < \frac{R_1}{R_2} V_M
\]

Se il guadagno d'anello \'e maggiore di $1$ in modulo si \'e rischio di stabilit\'a

Guadagno amplificatore operazionale $\to \infty$ in alto guadagno
\section{Circuito Bistabile (Circuiti Schmitt trigger)}

\begin{circuitikz}
    \draw (0, 0) node[eground]{} to[R] (2, 0)
    node[op amp, anchor=-](amp){};
    \draw (amp.+) to[short, -o] ++(-0.5, 0) node[left]{$V_i$};
    \draw (amp.-) -- ++(0, 1) coordinate(ang)
    (ang) to[R]  (amp.out |- ang) -- (amp.out) to[short, -o] ++(1, 0) node[right]{$V_u$};
\end{circuitikz}


\underline{AG}
\[
    \begin{rcases}
        V_{id} = 0  \rightarrow V^+ = V^- = V_i\\
        I_1 = I_2 + \cancel{I^+}\\
        \frac{0 - V^+}{R_1} = \frac{V^+ - V_u}{R_L}
    \end{rcases}
    -\frac{V_i}{R_1} = \frac{V_i - V_u}{R_2} \rightarrow -V_i \left( \frac{R_2}{R_1} + 1\right) = V_u \Rightarrow V_u = V_i\left( 1 + \frac{R_1}{R_2}\right)
\]

\[ V_M = V_i^*\left( 1 + \frac{R_2}{R_1}\right) \rightarrow V_i^* = \frac{V_M}{1 + \frac{R_2}{R_1}} \]
\underline{SAT +}
\[
    \begin{rcases}
        \begin{rcases}
            V_u = +V_M\\
            V_{id} > 0 \rightarrow V^+ > V^- = V_i\\
            I_1 = I_2 + \cancel{I^+}\\
            \frac{0 - V^+}{R_1} = \frac{V^+ - V_u}{R_2}
        \end{rcases} \rightarrow -\frac{V^+}{R_1} = \frac{V^+ - V_M}{R_2} \rightarrow -V^+ \left( \frac{1}{R_1} + \frac{1}{R_2} \right)= - \frac{V_M}{R_2}\\
        V^+\left( \frac{R_1 + R_2}{R_1\cancel{R_2}}\right) = \frac{V_M}{R_2} \rightarrow
        V^+ =\frac{R_1}{R_1 + R_2} V_M = \frac{V_M}{1+\frac{R_2}{R_1}}
    \end{rcases}
    V_i < \frac{V_M}{1 + \frac{R_2}{R_1}}
\]
\subsection{Trigger invertente}
\begin{center}
    \begin{tikzpicture}
        \begin{axis}[axis lines=middle, ymax=3, ymin=-3, yticklabels=\empty, xticklabels=\empty, xlabel=$V_i$, ylabel=$V_u$]
            \addplot[color=red, domain=-4:1]{2};
            \addplot[color=red, domain=-1:4]{-2};
            \addplot+[mark=none, color=red] coordinates{(-1, -2) (1, 2)};
        \end{axis}
    \end{tikzpicture}
\end{center}


\subsection{Trigger non invertente}
\begin{center}
    \begin{tikzpicture}
        \begin{axis}[axis lines=middle, ymax=3, ymin=-3, yticklabels=\empty, xticklabels=\empty, xlabel=$V_i$, ylabel=$V_u$]
            \addplot[color=red, domain=-1:4]{2};
            \addplot[color=red, domain=-4:1]{-2};
            \addplot+[mark=none, color=red] coordinates{(-1, 2) (1, -2)};
            \addplot+[mark=none, color=blue] coordinates{(-4, -2) (1, -2) (1, 2) (4, 2)};
            \addplot+[mark=none, color=green] coordinates{(4, 2) (-1, 2) (-1, -2)};
        \end{axis}
    \end{tikzpicture}
\end{center}

Aumentando il valore della tensione di ingresso (da Va) continuo a rimanere nello stesso tratto di curva, senza salti

Se sono al valore basso $-V_M$, per passare al valore alto devo applicare una tensione di ingresso che \'e almeno $V^*$
Se sono al valore alto, per passare al valore basso devo applicare una tensione che \'e minore di $-V^*$

Nella fascia di ambiguit\'a se sono al valore basso rimango al valore basso, se sono a quallo alto rimango in quello alto

Viene percorso un \textbf{Ciclo di isteresi}

Questo circuito \'e Molto pi\'u resistente al rumore rispetto ad un circuito a soglia per la fascia di ambiguit\'a

Applicando prima un segnale molto positivo, e riportando il segnale a 0 l'uscita rimane positiva. L'uscita del valore in 0, dipende dalla `storia' del circuito. Questo circuito si ricorda se l'ultimo valore applicato \'e positivo o negativo (\'e una Cella di memoria).

\'E in grado di mantenere fin tanto che \'e acceso un valore binario in memoria $\rightarrow$ Passaggio da reti combinatorie a reti sequenziali

\newpage
%Appunti del  Thu 30 May 2019 03:01:57 PM CEST
\section{Circuito Astabile}

\begin{circuitikz}

\end{circuitikz}
(X: Circuito 1)

\[
    \begin{split}
        &V_i(0) = 0\\
        &V_u(0) = V_M \rightarrow \text{SAT +?} \rightarrow V_{id} > 0 \text{?}
    \end{split}
\]

La condizione di alto guadagno del circuito abbiamo gi\'a visto che \'e sospetta (instabile), Possiamo presupporre che sia piu facile trovarsi in una delle due altre regioni

Ipotizzo inizialmente che la tensione all'inizio sia $V_M$ (in saturazione positiva)

Posso dire, svolgendo calcoli analoghi ai precedenti:
\[
    \begin{rcases}
        V_i = V^- = 0\\
        V^+ = V_M \frac{R_1}{R_1 + R_2} = \frac{V_M}{1 + \frac{R_2}{R_1}} > 0
    \end{rcases} V_{id} = V^+ - V^- > 0 \rightarrow \text{\'E in saturazione positiva!}
\]

\[
    \begin{rcases}
        I_R =\frac{V_i - V_u}{R}\\
        V_u = V_M\\
        I_C = C\frac{dV_i}{dt}\\
        I_C = - I_R
    \end{rcases}
    C \frac{dV_i}{dt} = - \frac{V_i - V_M}{R}
\]

Siccome $V_i$ innizialmente \'e uguale a 0, $V_M$ \'e positivo, vuol dire che il condensatore si sta caricando
\[
    \frac{dV_i}{V_i - V_M} = -\frac{dt}{RC}
\]

\[
    \int_{V_i(0) = 0}^{V_i(t)} \frac{dV_i}{V_i - V_M} = \int_0^t - \frac{dt}{RC}
\]
\[ -\frac{t}{RC} = -\ln\frac{V_i(t) - V_M}{-V_M}\xrightarrow{\exp} e^{-\frac{t}{RC}} = \frac{V_i(t) - V_M}{-V_M} \]
\[ V_i(t) = V_M - V_M e^{-\frac{t}{RC}} = V_M \left(1 - e^{-\frac{t}{RC}}\right) \]

Questo vale fino a quendo $V_i < Vi^*$

Osservando il condensatore nel momento $V_i = Vi^*$ (Il momento in cui cado nel ramo di saturazione negativa):

\[
    \begin{rcases}
        V_i^* > 0\\
        V_u = -V_M\\
        V^- = V_i\\
        V^+ = -V_M \frac{R_1}{R_2} = -\frac{V_M}{1 + \frac{R_2}{R_1}}\\
    \end{rcases}
        V_{id} = V^+ - V^- < 0 \rightarrow \text{Saturazione negativa}\\
    \]

\[
    \begin{rcases}
        I_R = \frac{V_i - V_u}{R} > 0\\
        I_R = -I_C
    \end{rcases} I_C < 0
\]

\begin{tikzpicture}
    \begin{axis}[axis lines=middle,
        ymax=3, ymin=-3,
        xmax=10,
        yticklabels=\empty, xticklabels=\empty, xlabel=$t$, ylabel=$V_i$]
        \addplot[color=red, domain=0:2]{3*(1-exp(-x))};
    \end{axis}
\end{tikzpicture}
\begin{tikzpicture}
    \begin{axis}[axis lines=middle,
        ymax=3, ymin=-3,
        xmax=10,
        yticklabels=\empty, xticklabels=\empty, xlabel=$t$, ylabel=$V_i$]
        \addplot[color=red, domain=0:2]{2};
        \addplot+[mark=none] coordinates{(2, 2) (2, -2)};
        \addplot[color=red, domain=2:4]{-2};
        \addplot+[mark=none, color=red] coordinates{(4, -2) (4, 2)};
        \addplot[color=red, domain=4:6]{2};
        \addplot+[mark=none, color=red] coordinates{(6, 2) (6, -2)};
        \addplot[color=red, domain=6:8]{-2};
    \end{axis}
\end{tikzpicture}

Continua ad oscillare, la frequenza dipende da $RC$

\begin{center}
\begin{circuitikz}
    \draw (0, 0) node[not port](n1){};
    \draw (n1.out) to[C] ++(0, -1) node[eground]{};
    \draw (n1.out) -- ++(1, 0) node[not port, anchor=in](n2){};
    \draw (n2.out) to[C] ++(0, -1) node[eground]{};
    \draw (n2.out) -- ++(1, 0) node[not port, anchor=in](n3){};
    \draw (n3.out) -- ++(0, -2) -- (n1.in |-, -2) -- (n1.in);
\end{circuitikz}
\end{center}

Attraversando una serie di porte logiche di questo tipo posso rigenerare il segnale (Qualit\'a rigenerativa delle logiche digitali)

Per controllare il ritardo del segnale basta metter in cascata pi\'u invertitori

Per controllare la frequenza dell'onda quadra, basta che aumenti il numero di ritardi? (Domanda Felice)

Dopo un numero pari di inversioni, se in ingresso si ha un valore alto, in uscita avr\'o lo stesso valore $\rightarrow$ Circuito bistabile

(Grafico 2)
\begin{tikzpicture}
    \begin{axis}[axis lines=middle,
        ymax=3, ymin=-3,
        xmax=10,
        yticklabels=\empty, xticklabels=\empty, xlabel=$x$, ylabel=$y$]
        \addplot[color=red, domain=0:1]{2};
        \addplot[color=red, domain=2.5:6]{0};
        \addplot+[mark=none, color=red] (1, 2)  parabola (2.5, 0);
    \end{axis}
\end{tikzpicture}

Questo circuito ha memoria; Se sono in grado di scrivere un valore alto o basso su quel nodo, l'uscita in 0 rimane salvata

(X: Circuito porte 2)

\begin{center}
\begin{circuitikz}
    \draw (0, 0) node[not port](n1){};
    \draw (n1.out) to[C] ++(0, -1) node[eground]{};
    \draw (n1.out) -- ++(1, 0) node[not port, anchor=in](n2){};
    \draw (n2.out) to[C] ++(0, -1) node[eground]{};
    \draw (n2.out) -- ++(1, 0) node[not port, anchor=in](n3){};
    \draw (n3.out) -- ++(0, -2) -- (n1.in |-, -2) -- (n1.in);
\end{circuitikz}
\end{center}
Nel caso l'interruttore sia attaccato: $Q = D$, altrimenti $Q^1 = Q$

Se voglio cambiare il valore memorizzato basta aprire l'anello ed applicare un valore dall'esterno

Utilizzando un segnale di clock al posto del segnale di scrittura, questo circuito alterna nel tempo una fase di scrittura e di lettura.
Circuito \underline{Trasparente}
\[
    \begin{aligned}
        CK &= 1 \rightarrow Q = D \rightarrow \text{Fase di valutazione dell'ingresso, EVALUATION}\\
        CK &= 0 \rightarrow Q^1 = Q \rightarrow \text{Fase di mantenimento, HOLD}
    \end{aligned}
\]

Questo circuito non \'e ancora un \textit{Flip Flop}, ma un \textit{Latch}. Quando siamo a $0$ l'uscita \'e bloccata all'ultimo segnale

(X: Grafici clock)
\begin{tikzpicture}
    \begin{axis}[axis lines=middle,
        ymax=3, ymin=-3,
        xmax=10,
        yticklabels=\empty, xticklabels=\empty, xlabel=$CK$]
        \addplot[color=red, domain=0:2]{2};
        \addplot+[mark=none] coordinates{(2, 2) (2, -2)};
        \addplot[color=red, domain=2:4]{-2};
        \addplot+[mark=none, color=red] coordinates{(4, -2) (4, 2)};
        \addplot[color=red, domain=4:6]{2};
        \addplot+[mark=none, color=red] coordinates{(6, 2) (6, -2)};
        \addplot[color=red, domain=6:8]{-2};
    \end{axis}
\end{tikzpicture}

(X: Altro grafico)
Dall'ultimo grafico si pu\'o vedere che non \'e un comportamento da rete sincron. Quello che posso fare \'e aggiungere a queso oggetto un secondo stadio, passando ad un circuito di tipo Master-Slave

Chiamo questo circuito \textit{p-latch}

(X: Circuiti n-latch, caso duale dell' n-latch)

Per creare un circuito di tipo master-slave basta che metto in cascata un circuito\textit{n-latch} con uno \textit{p-latch}.

(X: Foto 1)
(X: Grafici ambigui dopo foto)

Lo slave legge solo un valore: Quello alla fine dello stato di valutazione del master $\rightarrow$ Il valore dell'uscita pu\'o essere aggiornato solo nei fronti di discesa del clock. $\rightarrow$ \textit{Flip flop} sincrono

(X: Immagine flip flop, (post grefici ambigui))

Per un flip flop Positive triggered (Campionato sul fronte positivo): Scambiare p ed n latch; Prima il P dopo N latch

\subsection{Multiplexer}

(X: Circuito Multiplexer)
\begin{tabular}{c|c c c c}
    s-ab & 00 & 01 & 11 & 00\\
    \hline
    0  & 0 & 1 & 1 & 0  \\
    1 & 0 & 0 & 1 & 1
\end{tabular}
$\Rightarrow y = as + b\bar{s}$


(X: Or ingressi negati)


$ z = \bar{x} + \bar{y} = \bar{xy}$ (NAND)

MUX mi costa 12 transistori +2. Per fare un latch utilizzoaltri 2 transistori $\rightarrow$ Latch utilizza 16 (+2) transistori
Per la configurazione master-slave (\textit{Flip Flop di tipo D}) ne servono altri 16


\newpage
\section{Appunti Tue 04 Jun 2019 02:57:14 PM CEST}

\textbf{Multiplexer} $y = sa + \bar{s}b \Rightarrow \bar{y} = sa + \bar{s}b$

(X: Figura con transistori)


Non \'e un problema se il segnale $y$ torna invertito, lo devo utilizzare invertito nel circuito master-slave ugualmente

Per fare il multiplexer, prima servivano 16 transistori, ora nella figura siamo passati a 10. prima il segnale per andare dall'ingresso all'uscita deve attraversare due strati di nand e due di not, ($\times 2$ con master slave), nel nuovo circuito deve attraversarne solo 2.

\`E possibile implementare il mux anche con due interruttori; L'idea diventa quindi sostituire ai due interruttori due transistori controllari da una corrente (Da 8 a 2 transistori). (\textit{Pass Transistor})

Questo \'e il primo caso dove la corrente d'ingresso $I \neq 0$

\begin{circuitikz}
    \draw (0, 0) node[eground] {}
    to[C] (0, 2);
\end{circuitikz}

\underline{Caso $t < 0$}

M off
\[
    \begin{rcases}
         I_D = 0\\
         I_D = I_c
     \end{rcases} \rightarrow I_c = 0 \rightarrow I_C = C\frac{dV_u}{dt} = 0 \rightarrow V_u = cost
\]

 Se l'ingresso \'e 0, l'uscita pu\'o trovarsi in un uscita in condizioni di alta imedenza.
Il valore si mantiente dentro al condensatore

DRAM: Memoria dinamica associata ad un condensatore
questo circuito ha 3 tipi d'uscita

\begin{enumerate}
    \item alta
    \item bassa
    \item alta impedenza
\end{enumerate}

Nel momento in cui si accende il transistore i casi possibili sono:

\begin{tabular}{c c c}
    $V_i$ & $V_u$ \\
    \hline
    $V_L$ & $V_L$ & -\\
    $V_L$ & $V_H$ & * $V_u : V_H\to 0$\\
    $V_H$ & $V_L$ & ** $V_u: 0 \to V_{DD} - V_T$\\
    $V_H$ & $V_H$ & -\\
\end{tabular}

Studio il primo dei due fenomeni (*):

il nodo $V_u$ ha sempre potenziale piu alto rispetto all'ingresso, di conseguenza \'e il Drain, mentre $V_I$ \'e il source

\[
    \begin{rcases}
        I_D = - I_C\\
        I_D \ge 0\\
        I_C = C\frac{dV_u}{dt}
    \end{rcases}
    C\frac{dV_u}{dt} < 0
\]

Derivata negativa, la cerica del condensatore si sta esaurendo\\
Esattamente quello scritto quando abbiamo calcolato il tempo di scarica del condensatore cmos

Il transitorio termina quando la derivata si annulla $\rightarrow$ la corrente si annulla $\rightarrow V_{DS} = V_u$ si annulla

Tende ad assumere asintoticamente il valore nullo


Studiando il caso (**)
Drain e Source sono invertiti
\[
    \begin{rcases}
    I_D = I_C\\
    I_D \ge 0\\
    I_C = C \frac{dV_u}{dt}
\end{rcases}
C \frac{d V_u}{dt} \ge 0
\]


\[ I_D = \frac{\beta}{2}\left( V_{GS} - V_T\right) ^2 = 0 \]
\[ V_{DD} - V_i \rightarrow V_u = V_{DD} - V_T \]

Questo pass transistor \'e capace di trasferire uno \textit{0 Forte} ed un un \textit{1 Debole}
%%
Supponendo ora di avere lo stesso caso di prima (Alto in ingresso e basso in uscita che voglio portare alto) $\rightarrow$ Transitorio di carica di un invertitore cmos, inizialmente saturo fino a quando la tensione di uscita $> V_{TP} $, poi va in lineare

Quindi sappiamo gi\'a che l'uscita si porta da al valore $V_{DD}$

SAT $\to I_D = \frac{\beta_D}{2}\left(V_{SG} - |V_{TP}|\right)^2 = 0 \rightarrow V_{SG} = V_u = |V_{TP}|$

La rete di pulldown non \'e capace di scaricare completamente il transistore, si ferma una soglia prima

\bigbreak{}
\begin{tabular}{c c}
    $V_u : V_H \to V_L$ & n 0 forte\\
                        & p 0 debole  ($|V_{TP}|)$\\
                        \hline
    $V_u: V_L \to V_H$ & n 1 debole ($V_{DD} - V_T$)\\
                       & p 1 forte\\
\end{tabular}


Metto insieme p ed n mos per migliorare le prestazioni

\[ V_u : 0 \xrightarrow{n SAT\\p SAT} |V_{TP}| \xrightarrow{n SAT\\ p LIN} V_{DD} - V_{TN} \xrightarrow{OFF, LIN} V_{DD} \]
\[ V_u : V_{DD} \xrightarrow{n SAT\\ p SAT} V_{DD} - V_{TN} \xrightarrow{LIN\\SAT} |V_{TP}| \xrightarrow{LIN, OFF} 0 \]

Un oggetto di questo tipo si chima \textit{transmission gate}

Passando attraverso due invertitori, il valore d'uscita viene rigenerato

Questo multiplexer non \'e immune ai disturbi, il meglio che posso sperare \'e che il segnale esce ridotto al massimo di quanto ci aspettiamo

\begin{tabular}{c c|c}
    a & b & y\\
    \hline
    0 & 0 & 0\\
    0 & 1 & 0\\
    1 & 0 & 0\\
    1 & 1 & 1\\
\end{tabular}

\[ y = \begin{cases}
    a \quad \text{se} \, =0\\
        b \quad \text{se} \,a = 1\\
    \end{cases}
\]

Segnale $a$ \'e usato come selettore

Difetto: non abbiamo margine con l'immunit\'a ai disturbi

(X : Circuito and con multiplexer e transistor)

\underline{OR}

\begin{tabular}{c c|c}
    a & b & y\\
    \hline
    0 & 0 & 0\\
    0 & 1 & 1\\
    1 & 0 & 1\\
    1 & 1 & 1\\
\end{tabular}

(X: Circuito or con multiplexer transistor)

Mentre connettendo stadi cmos, la corrente di gate \'e nulla, in questo caso (pass transistor) la corrente che circola non \'e nulla. Il tempo di propagazione dipende dal tempo di carica e scarica delle capacit\'a parassita

Nel pass transistor le capacit\'a parassita sono caricate dalla corrente che entra in ingresso. In questo caso devo caricare una maggiore capacit\'a con a disposizione una corrente piu debole. Auentare il numero degli stadi vuol dire aumentare la capacit\'a da caricare e la resistenza



% Appunti Thu 06 Jun 2019 02:42:48 PM CEST
\newpage
\section{Appunti Thu 06 Jun 2019 02:42:48 PM CEST}

% Scorsa lezione
Bit Line:

Wired line

Meccanismo di indirizzamento attraverso un decoder

Decoder si frammenta in una struttura gerarchica id pi\'u righe e decoder

Rimane da capire cosa c'e' in un incrocio

%

R/W segnale di controllo che specifica lettura e scrittura

Memorie a sola lettura: Piu semplice ed economica rispetto ad una memmoria RW.

Classificazione tra memorie:

\begin{itemize}
    \item ROM: Read Only Memory; Il contenuto rimane invariato, si pone il problema di definire una volta per tutte il contenuto:
        \begin{itemize}
            \item (MP) Rom (Mask Programmable); Programmate in fabbrica

            \item \textbf{FP ROM} (Field Programmable ROM); Programmata dall'utente Genericamente chiamata (PROM: Rom Programmabile)
        \end{itemize}
    \item RWM: Read Write Memory
        \begin{itemize}
            \item Volatile RWM: Perde i dati quando manca l'alimentazione (RAM: Random Access Memory, Memoria ad accesso Arbitrario). Il tempo d'accesso all'informazione non dipende dalla posizione del dato (indirizzo).
                \begin{itemize}
                    \item Dato Memorizzato in maniera Statica (SRAM: Static Ram)
                    \item Dato Memorizzato in maniera Dinamica (DRAM: Dynmic RAM)
                \end{itemize}
            \item Non Volatile RWM: Permanente una volta che \'e stato scritto un dato, esso rimane nel tempo indefinitamente
                \begin{itemize}
                    \item EPROM
                    \item $E^2$PROM
                    \item FLASH EPROM
                    \item $\ldots$
                \end{itemize}
                La sigla ROM indica che l'operazione di lettura e di scrittura sono radicalmente diverse (tempi, tensioni applicate, $ldots$), sono progettate per essere lette frequentemente e programmate o scritte non cosi spesso.

                Chiamate Memorie a Prevalente Lettura (\textit{Read Mostly Memory})
        \end{itemize}
\end{itemize}

Come progettare L'incrocio con la memoria ROM

Ogni colonna di questa matrice \'e implementabile come la tabella di verit\'a alimentata dal decoder.

Per avere l'uscita negata basta che inverta la logica del circuito
% Nor

\textbf{NOR-BASED}

Se sulla tabella di verti\'a leggo uno $\rightarrow$ transistore nella rispettiva \textit{word}? line.
Anzich\'e invertire l'uscita, basta invertire se mettere o no il transistore in ingresso

Per programmare la memoria:

\begin{itemize}
    \item
        Nel caso in cui la programmi il fabbricante, sceglie se mettere o no il transistore, non \'e molto pratico, siccome la costruzione dei transistori \'e una delle prime fasi.

        Quello che si pu\'o fare \'e invece che agire sulle fasi iniziali della progettazione, agiamo sulle fasi finali: Costruisco una matrice, dove i transistori ci sono tutti; Ma siccome ogni transistore \'e collegato alla linea di bit, vuol dire che li devo connettere fisicamente alla linea metallica del segnale della bitline.

        Ovverso scelgo se collegare o no il transistore alla bitline. Se non lo collego, si comporta come se non ci fosse.
        \'E molto piu costoso differenziare i progetti, piuttosto che produrre qualche transistore in pi\'u.

        Rimane vero che il costo di questa operazione \'e elevato, si giustiica solamente per volumi di produzione sufficentemente grandi (MPROM)

    \item Programmazione sul campo, connetto tutti i transistori, attraverso un interconnessione particolare, rappresentabile impropiamente come un fusibile (tratto di circuito a resistenza elevata, se si scalda a sufficenza interrompe il circuito).

        La pista del fusiblile non si fonde quando leggo, ma quando scrivo: Corrente di fusione di programmazione \'e pi\'u alta,

        Fondere dove ho bisogno di un 1 nella tabella di verit\'a

    \item  Un altro metodo \'e scegliere la tensione di soglia $V_T$ dei transistori.
        \'E necessario modificare la tensione di soglia dinamicamente. Per non riportare il problema alla fabbricazione
        Tensione di soglia: Tensione da applicare al gate per far si che si formi sotto al gate un canale conduttivo, che corrisponde ad una certa densit\'a di elettroni.

        Se all'interno dell'ossido \'e intrappolata una carica negativa: Neutralizza una parte della carica positiva di Gate: La tensione di soglia si alza: \'E necessaria pi\'u carica di gate per avere la stessa tensione di soglia

        \textbf{Transistore a Doppio Gate}
\end{itemize}

Transistore a doppio gate: Ha dimensioni estremamente ridotte, quindi per \textit{Effetto tunnel} \'e possibile con probabilit\'a $\neq 0$ che un elettrone entri dentro lo strato isolato. Accelerando i portatori di canale posso fare si che una parte degli elettroni di canale entrino dentor e rimangano intrappolati dentro a questo \textit{Floating Gate}

In questo modo posso modificare la tensione di soglia variando le correnti di canale

Voglio che la velocit\'a degli elettroni (Energia cinetica)  di quando leggo e quando scrivo siano diverse (Pi\'u basse durante la lettura, pi\'u alte durante la programmazione). Segue che la lettura \'e molto pi\'u rapida

La probabilit\'a di effetto tunnel \'e molto ridotta per fare in modo che i dati non vengano variati durante la lettura.

A lungo andare \'e molto probabile che elettroni entrino dentro all'ossido, rimanendo permanentemente intrappolati. \textit{Fenomeno di Invecchiamento del transistore}. Il numero di volte che posso cancellare e programmare la memoria, non \'e infiito.

Vuol dire che posso leggere la memoria, un numero infinito di volte, ma posso scriverla solo un numero finito di volte. Non \'e utilizzabile come memoria centrale per un Computer. (Se ci voglio scrivere con una velocit\'a di 1 $GHz$ sarebbe esaurita in 1 secondo)

Chiamiamo queste memorie EPROM e  EEPROM (\textit{Elecrically Eraseable Programmable Read Only Memory})

\subsection{Memorie Voltatili}

Se connetto la cella alla bit line, la bit line influisce la cella: necessita distinzione tra lettura e scrittura.

Bistabile + Faccio competere con una rete forte se voglio scrivere ed una rete debole se voglio leggere (dalla cella): SRAM 5T(ransistori)

Alternativa: Condensatore isolato (Problema con capacit\'a parassita della bitline) (DRAM 1T), le operazioni di lettura sono molto pi\'u complicate). Si dice che la lettura \'e distruttiva.

Un altro problema \'e che se carico la cella, il condensatore \'e imperfetto, e poco alla volta perde carica. Periodicamente devo rigenerare i valori nelle celle (Operazione di Refresh). Questo rallenta le operazioni

Per questo motivo, le memorie di tipo statico sono significativamente pi\'u veloci delle memorie di tipo dinamico.

\subsection{Conversione ADC/DAC}
Ci limitiamo ad enunciare i principi (come nelle memorie) senza entrare nel dettaglio.

Convertitore ADC, entra un segnale esce una n-upla di bit, \'e implicita una perdita di informazione.

Immaginando che il segnale d'ingresso $V_{in}$ vari da 0 a $V_{SF}$.
Posso rappresentare in funzione dell'ingresso $V_{in}$ la rappresentazione decimale equivalente.

\begin{center}
\begin{tikzpicture}
    \begin{axis}[xmin=0, ymin=0]
        \addplot[color=red]{x};
    \end{axis}
\end{tikzpicture}
\end{center}


Assegno i possibiili valori d'ingresso a rispettivi valori binari per gli $a_0 \ldots a_n$: Processo di Quantizzazione
\[\frac{V_{FS}}{2^n} = Q\]

Se scelgo questo tipo di quantizzazione l'errore massimo \'e $Q$

\begin{center}
\begin{tikzpicture}
    \begin{axis}[xmin=0, ymin=0]
        \addplot[color=red]{x};
    \end{axis}
\end{tikzpicture}
\end{center}

In questo caso, tralasciando, l'ultimo intervallo l'errore massimo che ho \'e $\frac{Q}{2}$. Tutto questo funziona fino a quando non entro negli intervalli segnati.

% op amp
\begin{circuitikz}
    \draw (0, 0) node[op amp](oa){};
    \draw (-1, |- oa.-) node[left]{$t_1$} to[short , *-] (oa.-);

\end{circuitikz}

Serve un circuito in grado di leggere le soglie d'ingresso (Comparatore elementare)
\[ V_id = V_{i0} - t_1 > 0 \to V_{in} > t_1 \to V_u = V_M \]

Siccome devo osservare 3 soglie: 3 Amplificatori operazionali

% 3 op amp
\begin{circuitikz}

\end{circuitikz}
Codice a 3 monitor

($V_{FS}$ Tensione di fondoscala)

\begin{itemize}
    \item Generare i valori di riferimento:
        Siccome entra una corrente nulla nell'operazionale basta un partitore. (Per riprodurre le tensioni basta mettere resistenze proporzionali)
    \item ABC \'e gia un uscita digitale: Convertire il codice termometro in un codice binario

        \begin{minipage}{0.3\textwidth}
            \begin{tabular}{c c c|c c c }
                A & B & C & $a_1$ & $a_0$\\
                \hline
                0 & 0 & 0 & 0 & 0\\
                0 & 0 & 1 & 0 & 1\\
                0 & 1 & 0 & - & -\\
                0 & 1 & 1 & 1 & 0\\
                1 & 0 & 0 & - & -\\
                1 & 0 & 1 & - & -\\
                1 & 1 & 0 & - & -\\
                1 & 1 & 1 & 1 & 1\\
            \end{tabular}
        \end{minipage}
        \begin{minipage}{0.6\textwidth}
        \begin{tabular}{c|c|c|c|c|}
            A/BC & 00 & 01 & 11 & 10\\
            \hline
            0 & 0 & 0& 1 & -\\
            \hline
            1 & - & - & 1 & -\\
            \hline
        \end{tabular} $\Rightarrow a_1 = B$
        \bigbreak
        \begin{tabular}{c|c|c|c|c|}
            A/BC & 00 & 01 & 11 & 10\\
            \hline
            0 & 0 & 1& 0 & -\\
            \hline
            1 & - & - & 1 & -\\
            \hline
        \end{tabular} $\Rightarrow a_0 = A + \bar{B}C$
        \end{minipage}

        Convertitore di tipo Flash
\end{itemize}

Numero decimale che rappresenta l'n-upla di bit posso scriverlo come
\[A = \sum\limits_{i=0}^{n-1} a_i2^i  = 2^n\sum\limits_{i=0}^{n-1} a_i2^{i-n} \]
\[ \sum\limits_{i=0}^{n-1} a_i2^{i-n} \approx 1 \]

\[\sum\limits_{i=0}^{n-1} a_i2^{i-n} V_{FS} = a_{n-1}\frac{V_{FS}}{2} + a_{n-2}\frac{V_FS}{4} \ldots a_0\frac{V_{FS}}{2^n}\]

Ho ricondotto il problema ad una somma di tensioni proporzionale a $V_{FS}$ : Basta un circuito sommatore
% sommatore
\[ V_ = - \left( \frac{R}{R_1} V_1 + \frac{R}{R_2}V_2\right) \]

\[ V_u = a_1 \frac{V_{FS}}{2} + a_0\frac{V_{FS}}{4} \]
Immaginando di applicare il principio di sovrapposizione degli effetti
\[  a_1a_0 = 01\qquad V_u = \cancel{a_0}\frac{V_{FS}}{4} = -\left(\frac{R}{R_1}V_1 + \frac{R}{R_2} V_2\right) \]
\[ R_2 = 4R\frac{V_H}{V_{FS}} \]

Altro caso $a_1a_0 = 10$
\[ V_u = \cancel{a_1} \frac{V_{FS}}{2} + \cancel{a_0 + \frac{V_{FS}}{4}}  = -\frac{R}{R_1} V_H \to
    R_1 = 2R \frac{V_H}{V_{FS}}
\]


\end{document}

